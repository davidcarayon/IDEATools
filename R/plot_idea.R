#' Plot IDEA4 results
#'
#' Produces ggplots and/or SVG source code with IDEA data produced by either \code{compute_idea()} or \code{old_idea()} call.
#'
#' @param IDEA_data an IDEA_data or IDEA_group_data object
#' @param choices Which type of plots should be produced ? Can be either "dimensions", "trees" or "radars" or a combination of these 3. Ignored if IDEA_data is of class \code{IDEA_group_data}.
#'
#' @return a named list of plots of class \code{IDEA_plots} or \code{IDEA_group_plots}. The algorithm also adds a "data" attribute containing data introduced in the input of this function.
#'
#' @details This function will produce different plots depending on whether the input data is of class \code{IDEA_data} or \code{IDEA_group_data}.
#'
#' The \code{IDEA_data} class implies that the data comes from an individual analysis pipeline, so individual plots will be produced according to the user's choices specified in the function call :
#'
#'  \describe{
#'   \item{dimensions}{This option will produce histograms for dimensions, components, and indicators along with a polarised synthetic representation for components.}
#'   \item{trees}{This option will produce the colored trees describing the qualitative agregation in the property approach.}
#'   \item{radars}{This option will produce polarised histograms (also called 'radars') giving the score (in %) of each indicator, grouped by property}
#' }
#'
#' Important note : All 3 types of plots are required for the "report" option of the \code{write_idea()} function.
#'
#' The \code{IDEA_group_data} class can only be generated by a "\code{diag_idea()}" group call which will iterate either "\code{read_idea() %>% compute_idea()}" or "\code{old_idea()}" on each data file before aggregating results and assigning this grouped class.
#'
#' As the \code{IDEA_group_data} class implies that the data comes from a group analysis pipeline, the \code{choices} argument will be ignored. The plots produced for the dimension approach are almost the same as in the individual analysis pipeline but with the histograms being replaced by boxplots. Concerning properties, the only visualization currently considered as relevant is a matrix (or heatmap) of properties * farms, with the cells colored according to the qualitative evaluation for each farm for a given property.
#'
#' Note that plots are using a "\code{theme_idea()}" theme defined in this package.
#'
#' A copy of the blank canvas used for colored trees can be locally exported as svg files with :
#'
#' \code{IDEATools::show_canvas()}
#'
#' Further information about the colored trees ans canvas can be found in this vignette :
#'
#' \code{vignette("colored_trees", package = "IDEATools")}
#'
#' @export
#'
#' @encoding UTF-8
#'
#' @importFrom dplyr inner_join distinct mutate rowwise ungroup arrange filter pull case_when select
#' @importFrom ggimage geom_image
#' @import pdftools
#' @importFrom ggplot2 ggplot geom_bar aes position_dodge geom_hline scale_fill_manual geom_label theme element_text element_blank guides labs coord_flip facet_wrap geom_rect geom_col geom_vline coord_polar ylim ggsave xlim theme_void unit geom_text scale_y_continuous
#' @importFrom ggpubr ggtexttable ttheme colnames_style rownames_style tbody_style ggarrange
#' @importFrom glue glue
#' @importFrom purrr map2_dbl
#' @importFrom stringr str_detect str_extract_all str_replace
#' @importFrom tibble tribble tibble
#' @importFrom tidyr gather
#'
#' @examples
#' library(IDEATools)
#'
#' ## Example given for a single analysis. See diag_idea() for a group analysis.
#' path <- system.file("idea_example.json", package = "IDEATools")
#' my_data <- read_idea(path)
#' computed_data <- compute_idea(my_data)
#'
#' ## Example without radars
#' idea_plots <- plot_idea(computed_data, choices = c("dimensions","trees"))
plot_idea <- function(IDEA_data, choices = c("dimensions", "trees", "radars")) {

  ## Check if correct input
  if (!any(class(IDEA_data) %in% c("IDEA_data", "IDEA_group_data"))) (stop("The input data is not of class 'IDEA_data'"))

  # Initializes the empty plot list to return
  plotlist <- list()

  # Custom function to attribute a code to each node
  replace_indic <- function(indic) {
    list_indic <- reference_table %>%
      dplyr::filter(level == "indicateur") %>%
      dplyr::pull(indic_code)

    res <- dplyr::case_when(
      indic %in% list_indic ~ indic,
      indic == "Diversit\u00e9 de l'organisation spatiale et temporelle" ~ "R1",
      indic == "Limiter l'exposition aux al\u00e9as" ~ "R2",
      indic == "Diversit\u00e9 des activit\u00e9s" ~ "R3",
      indic == "En favorisant la diversit\u00e9" ~ "R4",
      indic == "De l'outil de production" ~ "R5",
      indic == "En d\u00e9veloppant l'inertie et les capacit\u00e9s tampon" ~ "R6",
      indic == "R\u00e9duire la sensibilit\u00e9" ~ "R7",
      indic == "par l'insertion dans les r\u00e9seaux" ~ "R8",
      indic == "Augmenter la capacit\u00e9 d'adaptation" ~ "R9",
      indic == "Robustesse" ~ "R10",

      indic == "Naturelles" ~ "CP1",
      indic == "Travail" ~ "CP2",
      indic == "Comp\u00e9tences et \u00e9quipements" ~ "CP3",
      indic == "Sociales et humaines" ~ "CP4",
      indic == "Pr\u00e9server ou cr\u00e9er des ressources pour l'acte de production" ~ "CP5",
      indic == "D\u00e9velopper la capacit\u00e9 alimentaire" ~ "CP6",
      indic == "Capacit\u00e9 \u00e0 produire dans le temps des biens et services remun\u00e9r\u00e9s" ~ "CP7",
      indic == "Capacit\u00e9 de remboursement" ~ "CP8",
      indic == "Capacit\u00e9 \u00e0 d\u00e9gager un revenu dans le temps" ~ "CP9",
      indic == "Capacit\u00e9 productive et reproductive de biens et de services" ~ "CP10",

      indic == "Libert\u00e9 de d\u00e9cision organisationnelle" ~ "AU1",
      indic == "Libert\u00e9 de d\u00e9cision dans les relations commerciales" ~ "AU2",
      indic == "Disposer d'une libert\u00e9 de d\u00e9cision dans ses choix de gouvernance et de production" ~ "AU3",
      indic == "Disposer d'une autonomie financi\u00e8re" ~ "AU4",
      indic == "Autonomie dans le processus productif" ~ "AU5",
      indic == "Autonomie" ~ "AU6",

      indic == "Partage et transparence des activit\u00e9s productives" ~ "RG1",
      indic == "Ouverture et relation au monde non agricole" ~ "RG2",
      indic == "S\u00e9curit\u00e9 alimentaire" ~ "RG3",
      indic == "Implications et engagements sociaux" ~ "RG4",
      indic == "Ressources naturelles" ~ "RG5",
      indic == "Ressources \u00e9nerg\u00e9tiques et manufactur\u00e9es" ~ "RG6",
      indic == "Partager \u00e9quitablement les ressources" ~ "RG7",
      indic == "Conditions de travail de la main d'oeuvre " ~ "RG8",
      indic == "Conditions de travail de la main d'oeuvre" ~ "RG8",
      indic == "Conditions de vie et de travail" ~ "RG9",
      indic == "Bien \u00eatre de la vie animale" ~ "RG10",
      indic == "Contribuer \u00e0 la qualit\u00e9 de vie sur l'exploitation" ~ "RG11",
      indic == "R\u00e9duire les \u00e9missions" ~ "RG12",
      indic == "R\u00e9duire l'usage des produits polluants" ~ "RG13",
      indic == "R\u00e9duire ses impacts sur la sant\u00e9 et les \u00e9cosyst\u00e8mes" ~ "RG14",
      indic == "Responsabilit\u00e9 globale" ~ "RG15",

      indic == "Valoriser la qualit\u00e9 territoriale" ~ "AN1",
      indic == "Contribuer \u00e0 des d\u00e9marches d'\u00e9conomie circulaire" ~ "AN2",
      indic == "Par le travail et l'emploi" ~ "AN3",
      indic == "S'inscrire dans des d\u00e9marches de territoire" ~ "AN4",
      indic == "Ancrage territorial" ~ "AN5"
    )


    return(res)
  }

  # Individual analysis -----------------------------------------------------
  if (any(class(IDEA_data) == "IDEA_data")) {

    ## If the user chooses "dimensions"
    if (any(choices == "dimensions")) {


      ## Vector of colors for dimensions to use with each dimension plot
      vec_colors <- c("A"= "#2e9c15", "B" = "#5077FE", "C" = "#FE962B")


      ## Dimensions dataset
      res_dim <- IDEA_data$dataset %>%
        dplyr::inner_join(reference_table, by = "dimension_code") %>%
        dplyr::distinct(dimension_code, dimension, dimension_value) %>%
        dplyr::mutate(max_dim = 100) %>%
        dplyr::mutate(dimension = dplyr::case_when(dimension_code == "A" ~ vec_colors["A"],
                                                   dimension_code == "B" ~ vec_colors["B"],
                                                   dimension_code == "C" ~ vec_colors["C"]))

      ## Finding the lowest dimension value
      critiq <- min(res_dim$dimension_value)

      ## Create the plot
      plot_dimensions <- ggplot2::ggplot(res_dim, aes(
        x = dimension,
        y = dimension_value, group = factor(dimension)
      )) +
        ggplot2::geom_bar(ggplot2::aes(x = dimension, y = max_dim, fill = dimension),
                          alpha = 0.3, color = "black", position = ggplot2::position_dodge(width = 0.8),
                          stat = "identity"
        ) +
        ggplot2::geom_bar(ggplot2::aes(fill = dimension),
                          color = "black",
                          position = ggplot2::position_dodge(width = 0.8), stat = "identity"
        ) +
        ggplot2::geom_hline(yintercept = critiq, color = "red", size = 1.5, linetype = 5) +
        ggplot2::scale_fill_identity() +
        ggplot2::geom_label(ggplot2::aes(label = paste0(dimension_value, "/", max_dim)), fill = "white", size = 5) +
        theme_idea(base_size = 16) +
        ggplot2::theme(plot.caption = ggplot2::element_text(face = "bold")) +
        ggplot2::theme(panel.grid = ggplot2::element_blank()) +
        ggplot2::theme(
          axis.title = ggplot2::element_blank(),
          plot.title = ggplot2::element_blank()
        ) +
        ggplot2::guides(fill = FALSE) +
        ggplot2::scale_x_discrete(labels = c("Agro\u00e9cologique", "Socio-Territoriale", "Economique"))


      ## Components dataset
      res_compo <- IDEA_data$dataset %>%
        dplyr::inner_join(reference_table, by = c("dimension_code","component_code")) %>%
        dplyr::distinct(dimension,dimension_code, component_code, component, component_value, max_compo) %>%
        dplyr::rowwise() %>%
        dplyr::mutate(component = wrapit(component, width = 40)) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(component = factor(component, levels = rev(component))) %>%
        dplyr::mutate(dimension = dplyr::case_when(dimension_code == "A" ~ vec_colors["A"],
                                                   dimension_code == "B" ~ vec_colors["B"],
                                                   dimension_code == "C" ~ vec_colors["C"]))

      ## Plot for components
      plot_components <- ggplot2::ggplot(res_compo, ggplot2::aes(
        x = component, y = component_value,
        group = factor(dimension)
      )) +
        ggplot2::geom_bar(ggplot2::aes(x = component, y = max_compo, fill = dimension),
                          alpha = 0.3, color = "black", position = ggplot2::position_dodge(width = 0.8),
                          stat = "identity"
        ) +
        ggplot2::geom_bar(ggplot2::aes(fill = dimension),
                          color = "black",
                          position = ggplot2::position_dodge(width = 0.8), stat = "identity"
        ) +
        ggplot2::geom_label(ggplot2::aes(label = paste0(component_value, "/", max_compo)), fill = "white", size = 5.5) +
        ggplot2::scale_fill_identity("Dimension", labels = c("Agro\u00e9cologique", "Socio-Territoriale", "Economique"), guide = "legend") +
        theme_idea(base_size = 16) +
        ggplot2::theme(axis.title = ggplot2::element_blank()) +
        ggplot2::theme(panel.grid = ggplot2::element_blank()) +
        ggplot2::labs(fill = "Dimension", y = "Valeur de la composante / valeur max") +
        ggplot2::theme(legend.position = "bottom") +
        ggplot2::coord_flip()

      ## Indicators dataset
      res_indic <- IDEA_data$dataset %>%
        dplyr::distinct(indic, scaled_value, component_value) %>%
        dplyr::inner_join(reference_table, by = c("indic" = "indic_code")) %>%
        dplyr::rowwise() %>%
        dplyr::mutate(full_name = wrapit(full_name, width = 65)) %>%
        dplyr::ungroup() %>%
        dplyr::arrange(dimension_code, indic_number) %>%
        dplyr::mutate(full_name = factor(full_name, levels = rev(full_name))) %>%
        dplyr::rowwise() %>%
        dplyr::mutate(component = paste0("Composante : ", component, " (", component_value, "/", max_compo, ")")) %>%
        dplyr::mutate(component = wrapit(component, width = 70)) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(component = factor(component, levels = unique(component)))

      ### Agroecologie

      ## Subset for dimension A
      df <- res_indic %>% dplyr::filter(dimension_code == "A")

      ## Plot for indicators of dimension A
      plot_indic_ae <- ggplot2::ggplot(df, ggplot2::aes(x = full_name, y = scaled_value)) +
        ggplot2::geom_bar(ggplot2::aes(x = full_name, y = max_indic), fill = "#2e9c15",
                          alpha = 0.3, color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity"
        ) +
        ggplot2::geom_bar(fill = "#2e9c15", color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity") +
        ggplot2::facet_wrap(~component, ncol = 1, scales = "free_y") +
        ggplot2::geom_label(ggplot2::aes(label = paste0(scaled_value, "/", max_indic)), fill = "white", size = 4) +
        theme_idea(base_size = 14) +
        ggplot2::guides(fill = FALSE) +
        ggplot2::labs(fill = "Dimension", y = "Valeur de l'indicateur / valeur max") +
        ggplot2::theme(legend.position = "top") +
        ggplot2::theme(axis.title = ggplot2::element_blank()) +
        ggplot2::theme(panel.grid = ggplot2::element_blank()) +
        ggplot2::coord_flip()

      ### Socio-Territorial

      ## Subset for dimension B
      df <- res_indic %>% dplyr::filter(dimension_code == "B")

      ## Plot for indicators of dimension B
      plot_indic_st <- ggplot2::ggplot(df, ggplot2::aes(x = full_name, y = scaled_value, fill = dimension)) +
        ggplot2::geom_bar(ggplot2::aes(x = full_name, y = max_indic), fill = "#5077FE",
                          alpha = 0.3, color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity"
        ) +
        ggplot2::geom_bar(fill = "#5077FE", color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity") +
        ggplot2::facet_wrap(~component, ncol = 1, scales = "free_y") +
        ggplot2::geom_label(ggplot2::aes(label = paste0(scaled_value, "/", max_indic)), fill = "white", size = 4) +
        theme_idea(base_size = 14) +
        ggplot2::guides(fill = FALSE) +
        ggplot2::labs(fill = "Dimension", y = "Valeur de l'indicateur / valeur max") +
        ggplot2::theme(legend.position = "top") +
        ggplot2::theme(axis.title = ggplot2::element_blank()) +
        ggplot2::theme(panel.grid = ggplot2::element_blank()) +
        ggplot2::coord_flip()


      ### Economique

      ## Subset dimension C
      df <- res_indic %>% dplyr::filter(dimension_code == "C")

      ## Plot for indicators of dimension C
      plot_indic_ec <- ggplot2::ggplot(df, ggplot2::aes(x = full_name, y = scaled_value, fill = dimension)) +
        ggplot2::geom_bar(ggplot2::aes(x = full_name, y = max_indic), fill = "#FE962B",
                          alpha = 0.3, color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity"
        ) +
        ggplot2::geom_bar(fill = "#FE962B", color = "black", position = ggplot2::position_dodge(width = 0.8), stat = "identity") +
        ggplot2::facet_wrap(~component, ncol = 1, scales = "free_y") +
        ggplot2::geom_label(ggplot2::aes(label = paste0(scaled_value, "/", max_indic)), fill = "white", size = 4) +
        theme_idea(base_size = 14) +
        ggplot2::guides(fill = FALSE) +
        ggplot2::labs(fill = "Dimension", y = "Valeur de l'indicateur / valeur max") +
        ggplot2::theme(legend.position = "top") +
        ggplot2::theme(axis.title = ggplot2::element_blank()) +
        ggplot2::theme(panel.grid = ggplot2::element_blank()) +
        ggplot2::coord_flip()

      ### Polarised components plot

      # temporary pdf file
      temp_pdf <- file.path(tempdir(), "plot.pdf")

      # data for standardized components (%)
      component_data <- res_compo %>%
        dplyr::mutate(score = round((component_value / max_compo) * 100))

      ## First plot : Polarised histogram exported to pdf
      ggplot2::ggplot(component_data, ggplot2::aes(x = component_code, y = score, fill = dimension)) +
        ggplot2::geom_rect(xmin = 0, xmax = 13, ymin = -3, ymax = 0, fill = "black") +
        ggplot2::geom_col(color = "black", width = 1) +
        ggplot2::geom_vline(xintercept = c(seq(0.5, 13.5, 1)), color = "black") +
        ggplot2::geom_hline(yintercept = c(0, 20, 40, 60, 80, 100), color = "black") +
        ggplot2::geom_label(x = 0.5, y = 20, label = "20%", size = 5, inherit.aes = FALSE) +
        ggplot2::geom_label(x = 0.5, y = 40, label = "40%", size = 5, inherit.aes = FALSE) +
        ggplot2::geom_label(x = 0.5, y = 60, label = "60%", size = 5, inherit.aes = FALSE) +
        ggplot2::geom_label(x = 0.5, y = 80, label = "80%", size = 5, inherit.aes = FALSE) +
        ggplot2::scale_fill_identity() +
        ggplot2::coord_polar() +
        ggplot2::ylim(-3, 100) +
        ggplot2::theme(
          panel.background = ggplot2::element_blank(),
          panel.border = ggplot2::element_blank(),
          axis.text = ggplot2::element_blank(),
          axis.ticks = ggplot2::element_blank(),
          axis.title = ggplot2::element_blank()
        ) +
        ggplot2::guides(fill = FALSE) +
        ggplot2::ggsave(temp_pdf, dpi = 320, width = 10.1, height = 7.53, device = cairo_pdf)


      ## Preparing surrounding donut
      donut_data <- data.frame(
        category = c("#2e9c15", "#5077FE", "#FE962B"),
        count = c(38.46, 30.7, 30.7)
      )

      donut_data$fraction <- donut_data$count / sum(donut_data$count)
      donut_data$ymax <- cumsum(donut_data$fraction)
      donut_data$ymin <- c(0, head(donut_data$ymax, n = -1))


      ## Locate the "img" folder
      img_folder <- system.file("img", package = "IDEATools")


      ## Create a tibble with file paths for each component
      path_tab <- tibble::tribble(
        ~component_code, ~path,
        "COMP1", "picto_div.png",
        "COMP2", "picto_flux.png",
        "COMP3", "picto_ressources.png",
        "COMP4", "picto_production.png",
        "COMP5", "picto_sante.png",
        "COMP6", "picto_alimentation.png",
        "COMP7", "picto_circulaire.png",
        "COMP8", "picto_emploi.png",
        "COMP9", "picto_ethique.png",
        "COMP10", "picto_economique.png",
        "COMP11", "picto_independance.png",
        "COMP12", "picto_transmissibilite.png",
        "COMP13", "picto_efficience.png"
      ) %>%
        dplyr::rowwise() %>%
        dplyr::mutate(path = file.path(img_folder, path)) %>%
        dplyr::ungroup()


      ## Arrange component data and join with paths
      path_data <- component_data %>%
        dplyr::mutate(order = 1:13) %>%
        dplyr::inner_join(path_tab, by = c("component_code")) %>%
        dplyr::arrange(order)


      # Make the polarised plot
      plot_components_polarised <- ggplot2::ggplot(donut_data, ggplot2::aes(
        ymax = ymax, ymin = ymin,
        xmax = 3.45, xmin = 3, label = category
      )) +
        ggimage::geom_image(ggplot2::aes(x = 2.0, y = 1), image = temp_pdf, size = I(0.46)) +
        ggplot2::geom_rect(ggplot2::aes(fill = category), color = "black", alpha = 0.6) +
        ggimage::geom_image(ggplot2::aes(x = 3.35, y = 0.1823), image = file.path(img_folder, "TEXT_AE.png"), size = I(0.13), color = "#2e9c15") +
        ggimage::geom_image(ggplot2::aes(x = 3.45, y = 0.5431), image = file.path(img_folder, "TEXT_ST.png"), size = I(0.27), color = "#5077FE") +
        ggimage::geom_image(ggplot2::aes(x = 3.45, y = 0.8451), image = file.path(img_folder, "TEXT_ECO.png"), size = I(0.15), color = "#FE962B") +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.15 / 4), image = path_data$path[1], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.23 / 4 * 2), image = path_data$path[2], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.19), image = path_data$path[3], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.27), image = path_data$path[4], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.34), image = path_data$path[5], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.42), image = path_data$path[6], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.499), image = path_data$path[7], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.575), image = path_data$path[8], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.66), image = path_data$path[9], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.735), image = path_data$path[10], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.805), image = path_data$path[11], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.885), image = path_data$path[12], size = I(0.05)) +
        ggimage::geom_image(ggplot2::aes(x = 3.225, y = 0.965), image = path_data$path[13], size = I(0.05)) +
        ggplot2::coord_polar(theta = "y") +
        ggplot2::scale_fill_identity() +
        ggplot2::xlim(c(2, 4.9)) +
        ggplot2::theme_void() +
        ggplot2::guides(fill = FALSE) +
        ggplot2::theme(plot.margin = ggplot2::unit(c(-5, -5, -5, -5), "cm"))



      ## Aggregate plots in the return plotlist
      plotlist$dimensions <- list(
        plot_dimensions = plot_dimensions,
        plot_components = plot_components,
        plot_components_polarised = plot_components_polarised,
        plot_indic_ae = plot_indic_ae,
        plot_indic_st = plot_indic_st,
        plot_indic_ec = plot_indic_ec
      )
    }

    ## If user chooses "trees"
    if (any(choices == "trees")) {

      ## Custom functions

      ### Function to find positions of rect< > tags
      find_pos <- function(start, end, choice, car) {
        selection <- car[start:end]
        rect_id <- start + which(stringr::str_detect(selection, "id=") == TRUE) - 1
        rect_style <- start + which(stringr::str_detect(selection, "style=") == TRUE) - 1
        val <- switch(choice,
                      "id" = rect_id,
                      "style" = rect_style
        )
        return(val)
      }

      # Empty return list
      prop_list <- list()

      ## For loop on each property + another synthetic one
      for (prop in c(names(IDEA_data$nodes), "Global_zoom")) {

        ## Get the list of indicators of a given property
        list_indic_prop <- indic_codes[[prop]]

        ## We select the correct canvas from internal object (RAW SVG code)
        car <- canvas[[prop]]

        ## Each canvas has a different number of rectangles to find.
        span_rect <- switch(prop,
                            "Ancrage" = 14,
                            "Autonomie" = 16,
                            "Robustesse" = 26,
                            "Responsabilite" = 37,
                            "Capacite" = 24,
                            "Global" = 117,
                            "Global_zoom" = 20
        )

        ## Get the position of lines starting a rect tag
        rect_no <- which(stringr::str_detect(car, "    <rect") == TRUE)[1:span_rect]

        # creating a table with the coordinates of rectangle start, end, and style lines, along with the indicator identity
        tab_rect <- tibble::tibble(rect_no) %>%
          dplyr::mutate(rect_end = rect_no + 7) %>%
          dplyr::mutate(rect_id = purrr::map2_dbl(.x = rect_no, .y = rect_end, .f = find_pos, choice = "id", car = car)) %>%
          dplyr::mutate(rect_style = purrr::map2_dbl(.x = rect_no, .y = rect_end, .f = find_pos, choice = "style", car = car)) %>%
          dplyr::rowwise() %>%
          dplyr::mutate(rect_number_p = as.numeric(stringr::str_extract_all(car[rect_id], "[0-9]+")[[1]][1])) %>%
          dplyr::mutate(rect_number_c = as.numeric(stringr::str_extract_all(car[rect_id], "[0-9]+")[[1]][2])) %>%
          dplyr::ungroup() %>%
          dplyr::mutate(indic = list_indic_prop)

        # Extracting style column
        rect_style <- tab_rect$rect_style

        # Using the "Global" node for "Global_zoom" iteration of the loop
        filter_prop <- ifelse(prop == "Global_zoom", yes = "Global", no = prop)

        ## Table with the final indicator/color
        tab_to_color <- IDEA_data$nodes[[filter_prop]] %>%
          tidyr::gather(key = indic, value = result) %>%
          dplyr::mutate(indic = replace_indic(indic)) %>%
          dplyr::inner_join(tab_rect, by = "indic") %>%
          dplyr::arrange(rect_number_p, rect_number_c)


        ## Search and replace the "white" style in rectangles by the correct color.
        for (i in which(tab_to_color$result == "favorable")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#1CDA53")
        }

        for (i in which(tab_to_color$result == "tr\u00e8s favorable")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#0D8A00")
        }

        for (i in which(tab_to_color$result == "d\u00e9favorable")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#FF6348")
        }

        for (i in which(tab_to_color$result == "tr\u00e8s d\u00e9favorable")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#FF0000")
        }

        for (i in which(tab_to_color$result == "interm\u00e9diaire")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#FFA300")
        }

        for (i in which(tab_to_color$result == "NC")) {
          car[rect_style[i]] <- stringr::str_replace(car[rect_style[i]], "fill:#ffffff", "fill:#A0A0A0")
        }

        ## Add the result to the return list
        prop_list[[paste0("tree_", prop)]] <- paste(car, collapse = "\n")
      }

      ## Add the list of trees to the return plotlist
      plotlist$trees <- prop_list
    }

    ## If the user chooses "radars"
    if (any(choices == "radars")) {

      ## Vector of colors for dimensions to use with each dimension plot
      vec_colors <- c("A"= "#2e9c15", "B" = "#5077FE", "C" = "#FE962B")



      ## Creating a dataset with standardised indicators (%)
      prop_radar <- IDEA_data$dataset %>%
        dplyr::distinct(indic, scaled_value) %>%
        dplyr::inner_join(reference_table, by = c("indic" = "indic_code")) %>%
        dplyr::arrange(dimension_code, indic_number) %>%
        dplyr::mutate(score_indic = round(scaled_value / max_indic * 100, 0)) %>%
        dplyr::mutate(dimension = dplyr::case_when(dimension_code == "A" ~ vec_colors["A"],
                                                   dimension_code == "B" ~ vec_colors["B"],
                                                   dimension_code == "C" ~ vec_colors["C"]))


      ## Names
      prop_names <- c(
        "Ancrage",
        "Autonomie",
        "Robustesse",
        "Responsabilite",
        "Capacite"
      )

      # Empty list
      radarlist <- list()

      # For loop on each property
      for (i in prop_names) {

        ## Get the list of indicators of a given property
        list_indic_prop <- indic_codes[[i]]

        # Get the name and the y position of each label
        label_data <- prop_radar %>% dplyr::filter(indic %in% list_indic_prop)
        label_data$id <- seq(1, nrow(label_data))
        number_of_bar <- nrow(label_data)
        angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar
        label_data$hjust <- ifelse(angle < -90, 1, 0)
        label_data$angle <- ifelse(angle < -90, angle + 180, angle)
        label_data <- label_data %>% dplyr::filter(score_indic > 5)


        ## Build the table on the side of the plot
        mytable <- prop_radar %>%
          dplyr::filter(indic %in% list_indic_prop) %>%
          dplyr::select(indic) %>%
          dplyr::mutate(indic_code = as.character(indic)) %>%
          dplyr::inner_join(reference_table, by = "indic_code") %>%
          dplyr::rowwise() %>%
          dplyr::mutate(indic_name = wrapit(indic_name)) %>%
          dplyr::ungroup() %>%
          dplyr::arrange(dimension_code, indic_number) %>%
          dplyr::select(Code = indic_code, `Nom de l'indicateur` = indic_name)


        ## Re-identifying names
        prop_names <- c(
          "Ancrage",
          "Autonomie",
          "Robustesse",
          "Responsabilite",
          "Capacite"
        )

        ## (Manually) assigning colors to the table rows according to dimension
        colors <- list(
          Robustesse = c(rep("#2e9c15", 6), rep("#5077FE", 5), rep("#FE962B", 5)),
          "Capacite" = c(rep("#2e9c15", 3), rep("#5077FE", 7), rep("#FE962B", 4)),
          Autonomie = c(rep("#2e9c15", 3), rep("#5077FE", 4), rep("#FE962B", 3)),
          "Responsabilite" = c(rep("#2e9c15", 8), rep("#5077FE", 13), "#FE962B"),
          `Ancrage` = c(rep("#5077FE", 9))
        )

        ## Extracting the right color in this iteration of the loop
        mycols <- colors[[i]]

        ## Creating the table
        tab <- ggpubr::ggtexttable(mytable, rows = NULL, theme = ggpubr::ttheme(
          colnames.style = ggpubr::colnames_style(color = "black", size = 17, fill = "transparent", linecolor = "black"),
          rownames.style = ggpubr::rownames_style(fill = "transparent", size = 15, linecolor = "black"),
          tbody.style = ggpubr::tbody_style(fill = mycols, size = 15, linecolor = "black")
        ))


        ## Full property name for the plot title
        full_prop_name <- switch(i,
                                 "Ancrage" = "Ancrage Territorial",
                                 "Autonomie" = "Autonomie",
                                 "Robustesse" = "Autonomie",
                                 "Responsabilite" = "Responsabilit\u00e9 globale",
                                 "Capacite" = "Capacit\u00e9 productive et reproductive \nde biens et de services"
        )

        ## Building legend
        list_dimensions <- prop_radar %>% dplyr::filter(indic %in% list_indic_prop) %>% dplyr::distinct(dimension_code) %>% dplyr::pull()

        # A simple vector with dimension names
        vec_dim <- c("A"="Agro\u00e9cologique", "B" = "Socio-Territoriale", "C"= "Economique")

        ## The vector that will be used for legend
        vec_legend <- unname(vec_dim[list_dimensions])

        ## Creating the radar plot (polarised histogram)
        p <- ggplot2::ggplot(
          prop_radar %>% dplyr::filter(indic %in% list_indic_prop),
          ggplot2::aes(x = indic, y = score_indic, fill = dimension)
        ) +
          ggplot2::geom_rect(xmin = -Inf, ymin = -20, xmax = Inf, ymax = 100, fill = "white", color = "white") +
          ggplot2::geom_col(ggplot2::aes(x = indic, y = 100, fill = dimension), alpha = 0.3, color = "black") +
          ggplot2::geom_col() +
          ggplot2::geom_label(ggplot2::aes(label = paste0(score_indic,"%"))) +
          ggplot2::scale_fill_identity("Dimension", labels = vec_legend, guide = "legend") +
          theme_idea() +
          ggplot2::scale_y_continuous(limits = c(-20, 130), breaks = c(0, 20, 40, 60, 80, 100)) +
          ggplot2::theme(axis.text.x = ggplot2::element_text(size = 13, color = "black", face = "bold")) +
          ggplot2::theme(axis.text.y = ggplot2::element_blank()) +
          ggplot2::theme(axis.title = ggplot2::element_blank()) +
          ggplot2::theme(panel.grid = ggplot2::element_blank()) +
          ggplot2::labs(fill = "Dimension", title = glue::glue('Indicateurs de la propri\u00e9t\u00e9 "{full_prop_name}"')) +
          ggplot2::theme(legend.position = "top") +
          ggplot2::coord_polar()

        ## Adding the combination plot + table to return list
        radarlist[[paste0("radar_", i)]] <- ggpubr::ggarrange(p, tab)
      }

      ## Adding to the output plotlist
      plotlist$radars <- radarlist
    }

    # Saving original data in the list for future usage in write_idea.
    plotlist$data$metadata <- IDEA_data$metadata
    plotlist$data$dataset <- IDEA_data$dataset
    plotlist$data$nodes <- IDEA_data$nodes

    ## Assigning the appropriate class
    class(plotlist) <- c(class(plotlist), "IDEA_plots")
  }



  # Group analysis ----------------------------------------------------------

  if (any(class(IDEA_data) == "IDEA_group_data")) {

    # Number of farms
    n_farms <- dplyr::n_distinct(IDEA_data$dataset$farm_id)

    vec_colors <- c(
      "favorable" = "#1CDA53",
      "defavorable" = "#FF6348",
      "tres defavorable" = "#FF0000",
      "tres favorable" = "#0D8A00"
    )

    ## Heatmap for properties
    heatmap_data <- IDEA_data$nodes$Global %>%
      tidyr::gather(key = indic, value = result, -farm_id) %>%
      dplyr::mutate(indic = replace_indic(indic)) %>%
      dplyr::inner_join(reference_table, by = c("indic" = "indic_code")) %>%
      dplyr::filter(level == "propriete") %>%
      dplyr::mutate(indic_name = ifelse(indic_name == "Capacit\u00e9 productive et reproductive de biens et de services", yes = "Capacit\u00e9 productive et \n reproductive de biens et de \n services", no = indic_name)) %>%
      dplyr::mutate(result_ascii = stringi::stri_trans_general(result,id = "Latin-ASCII")) %>%
      dplyr::mutate(result_ascii = factor(result_ascii, levels = c("tres defavorable","defavorable","favorable","tres favorable"))) %>%
      dplyr::arrange(result_ascii)


    ## Building legend
    legend_names <- heatmap_data %>%
      dplyr::distinct(result) %>%
      dplyr::pull() %>%
      unname()

    heatmap <- heatmap_data %>%
      dplyr::mutate(result = stringi::stri_trans_general(result,id = "Latin-ASCII")) %>%
      dplyr::mutate(result = vec_colors[result]) %>%
      dplyr::mutate(result = factor(result, levels = c("#FF0000","#FF6348","#1CDA53","#0D8A00"))) %>%
      ggplot2::ggplot(ggplot2::aes(farm_id, indic_name, fill = result)) +
      ggplot2::geom_tile(color = "black") +
      ggplot2::scale_fill_identity("Evaluation", labels = legend_names, guide = "legend") +
      ggplot2::labs(x = "Exploitation", y = "Propri\u00e9t\u00e9", fill = "Evaluation") +
      theme_idea() +
      ggplot2::theme(axis.title.y = ggplot2::element_blank())

    ## Histograms for dimensions

    ## Data for dimensions
    dim_data <- IDEA_data$dataset %>%
      dplyr::distinct(farm_id, dimension_code, dimension_value) %>%
      dplyr::mutate(alpha = "b")

    ## dataframe with an "alpha" argument
    alpha <- dim_data %>%
      dplyr::mutate(dimension_value = 100 - dimension_value) %>%
      dplyr::mutate(alpha = "a")


    ## Vector of colors for dimensions to use with each dimension plot
    vec_colors <- c("A"= "#2e9c15", "B" = "#5077FE", "C" = "#FE962B")


    ## Full data for the dimension histogram
    hist_data <- dplyr::bind_rows(dim_data, alpha) %>%
      dplyr::mutate(label = ifelse(alpha == "a", yes = "", no = paste0(dimension_value, "/100"))) %>%
      dplyr::inner_join(reference_table, by = "dimension_code") %>%
      dplyr::distinct(dimension, dimension_value, dimension_code, farm_id, label, alpha) %>%
      dplyr::mutate(dimension = dplyr::case_when(dimension_code == "A" ~ vec_colors["A"],
                                                 dimension_code == "B" ~ vec_colors["B"],
                                                 dimension_code == "C" ~ vec_colors["C"])) %>%
      dplyr::arrange(dplyr::desc(dimension_code)) %>%
      dplyr::mutate(dimension = factor(dimension, levels = unique(dimension)))


    # Plotting dimensions histogram
    dimensions_histogram <- ggplot2::ggplot(hist_data, ggplot2::aes(x = farm_id, y = dimension_value, label = label, fill = dimension, alpha = alpha)) +
      ggplot2::scale_alpha_manual(values = c(0.6, 1)) +
      ggplot2::guides(alpha = FALSE) +
      ggplot2::geom_col(color = "black") +
      ggplot2::geom_text(ggplot2::aes(x = farm_id, y = dimension_value, label = label), position = ggplot2::position_stack(vjust = 0.5)) +
      ggplot2::scale_fill_identity("Dimension", labels = c("Economique","Socio-Territoriale","Agro\u00e9cologique"), guide = guide_legend(reverse = TRUE)) +
      theme_idea() +
      ggplot2::ylim(0, 300) +
      ggplot2::labs(x = "Exploitation", y = "Score", fill = "Dimension") +
      ggplot2::coord_flip()

    # Boxplots ----------------------------------------------------------------

    ## Dimensions

    ## Dimension data
    boxplot_dim_data <- dim_data %>%
      dplyr::inner_join(reference_table, by = "dimension_code") %>%
      dplyr::distinct(farm_id, dimension_code, dimension, dimension_value) %>%
      dplyr::mutate(dimension = dplyr::case_when(dimension_code == "A" ~ vec_colors["A"],
                                                 dimension_code == "B" ~ vec_colors["B"],
                                                 dimension_code == "C" ~ vec_colors["C"]))

    ## Estimating means to add on the boxplot
    means <- boxplot_dim_data %>%
      dplyr::group_by(dimension) %>%
      dplyr::summarise(Mean = mean(dimension_value))

    ## Plotting dimensions boxplot
    dimensions_boxplot <- ggplot2::ggplot(boxplot_dim_data, ggplot2::aes(x = dimension, y = dimension_value)) +
      ggplot2::stat_boxplot(geom = "errorbar", width = 0.3) +
      ggplot2::geom_boxplot(color = "black", ggplot2::aes(fill = dimension), width = 0.8) +
      ggplot2::geom_point(data = means, ggplot2::aes(x = dimension, y = Mean), size = 4, color = "darkred", shape = 18) +
      ggrepel::geom_label_repel(data = means, ggplot2::aes(x = dimension, y = Mean, label = paste0("Moyenne = ", round(Mean, 1))), nudge_x = 0.5, nudge_y = 5) +
      theme_idea() +
      ggplot2::scale_fill_identity("Dimension", labels = c("Agro\u00e9cologique","Socio-Territoriale","Economique"), guide = "legend") +
      ggplot2::theme(axis.title.x = ggplot2::element_blank()) +
      ggplot2::labs(y = "Valeur de la dimension", fill = "Dimension", caption = paste0("(N = ", n_farms, ")")) +
      ggplot2::scale_y_continuous(breaks = seq(0, 100, 10), limits = c(0, 100))+
      ggplot2::scale_x_discrete(labels = c("Agro\u00e9cologique", "Socio-Territoriale", "Economique"))



    ## Components

    ## Component data
    compo_data <- IDEA_data$dataset %>%
      dplyr::inner_join(reference_table, by = c("dimension_code", "component_code")) %>%
      dplyr::distinct(farm_id, dimension_code, dimension, component_code, component, component_value, max_compo) %>%
      dplyr::mutate(min_compo = 0) %>%
      dplyr::rowwise() %>%
      dplyr::mutate(component = wrapit(component, width = 60)) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(component = factor(component, levels = rev(unique(component))))

    ## Estimating means to add on the boxplot
    means <- compo_data %>%
      dplyr::group_by(dimension, component, component_code) %>%
      dplyr::summarise(Mean = mean(component_value)) %>%
      dplyr::ungroup()

    ## Plotting components boxplot
    components_boxplot <- ggplot2::ggplot(compo_data, ggplot2::aes(x = component, y = component_value)) +
      ggplot2::stat_boxplot(geom = "errorbar", width = 0.3) +
      ggplot2::geom_boxplot(color = "black", ggplot2::aes(fill = dimension), width = 0.8) +
      ggplot2::geom_point(data = means, ggplot2::aes(x = component, y = Mean, color = "Moyenne"), size = 4, shape = 18) +
      ggplot2::geom_point(ggplot2::aes(y = max_compo), shape = 93, size = 5, color = "red") +
      ggplot2::geom_point(ggplot2::aes(y = min_compo), shape = 91, size = 5, color = "red") +
      theme_idea() +
      ggplot2::scale_fill_manual(values = c("#2e9c15","#5077FE","#FE962B")) +
      ggplot2::scale_color_manual(values = c("darkred")) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::labs(y = "Valeur de la composante", fill = "Dimension", color = "L\u00e9gende", caption = paste0("(N = ", n_farms, ")")) +
      ggplot2::coord_flip() +
      ggplot2::guides(fill = FALSE) +
      ggplot2::facet_wrap(~dimension, ncol = 1, scales = "free", drop = TRUE) +
      ggplot2::scale_y_continuous(breaks = seq(0, 100, 5))

    ## Indicators

    ## Agroecologie

    ## Subset for dimension A
    indic_data <- IDEA_data$dataset %>%
      dplyr::inner_join(reference_table, by = c("indic" = "indic_code", "dimension_code", "component_code")) %>%
      dplyr::filter(dimension_code == "A") %>%
      dplyr::rowwise() %>%
      dplyr::mutate(full_name = wrapit(full_name, width = 75)) %>%
      dplyr::mutate(component = ifelse(component == "Bouclage de flux \nde mati\u00e8res et d'\u00e9nergie \npar une recherche d'autonomie",
                                       yes = "Bouclage de flux de mati\u00e8res et d'\u00e9nergie \npar une recherche d'autonomie",
                                       no = component
      )) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(indic_number) %>%
      dplyr::mutate(full_name = factor(full_name, levels = rev(unique(full_name)))) %>%
      dplyr::mutate(component = factor(component, levels = unique(component)))

    ## Estimating means to add on the boxplot
    moys <- indic_data %>%
      dplyr::group_by(component, full_name, indic) %>%
      dplyr::summarise(Moyenne = mean(scaled_value))

    ## Plotting indicators for dimension A
    indic_ae_boxplot <- ggplot2::ggplot(indic_data, ggplot2::aes(x = full_name, y = scaled_value)) +
      ggplot2::stat_boxplot(geom = "errorbar", width = 0.3) +
      ggplot2::geom_boxplot(color = "black", fill = "#2e9c15", width = 0.8) +
      ggplot2::geom_point(ggplot2::aes(y = 0), shape = 91, size = 5, color = "red") +
      ggplot2::geom_point(ggplot2::aes(y = max_indic), shape = 93, size = 5, color = "red") +
      ggplot2::facet_wrap(~component, ncol = 1, scales = "free") +
      ggplot2::coord_flip() +
      theme_idea() +
      ggplot2::scale_y_continuous(breaks = seq(0, 10, 1)) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::labs(y = "Valeur de l'indicateur", color = "L\u00e9gende", caption = paste0("(N = ", n_farms, ")"))

    ## Socio-Territorial

    ## Subset for dimension B
    indic_data <- IDEA_data$dataset %>%
      dplyr::inner_join(reference_table, by = c("indic" = "indic_code", "dimension_code", "component_code")) %>%
      dplyr::filter(dimension_code == "B") %>%
      dplyr::rowwise() %>%
      dplyr::mutate(full_name = wrapit(full_name, width = 75)) %>%
      dplyr::mutate(component = ifelse(component == "D\u00e9veloppement local \net \u00e9conomie circulaire",
                                       yes = "D\u00e9veloppement local et \u00e9conomie circulaire",
                                       no = component
      )) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(indic_number) %>%
      dplyr::mutate(full_name = factor(full_name, levels = rev(unique(full_name)))) %>%
      dplyr::mutate(component = factor(component, levels = unique(component)))

    ## Estimating means to add on the boxplot
    moys <- indic_data %>%
      dplyr::group_by(component, full_name, indic) %>%
      dplyr::summarise(Moyenne = mean(scaled_value))

    ## Plotting indicators for dimension B
    indic_st_boxplot <- ggplot2::ggplot(indic_data, ggplot2::aes(x = full_name, y = scaled_value)) +
      ggplot2::stat_boxplot(geom = "errorbar", width = 0.3) +
      ggplot2::geom_boxplot(color = "black", fill = "#5077FE", width = 0.8) +
      ggplot2::geom_point(ggplot2::aes(y = 0), shape = 91, size = 5, color = "red") +
      ggplot2::geom_point(ggplot2::aes(y = max_indic), shape = 93, size = 5, color = "red") +
      ggplot2::facet_wrap(~component, ncol = 1, scales = "free") +
      ggplot2::coord_flip() +
      theme_idea() +
      ggplot2::scale_y_continuous(breaks = seq(0, 10, 1)) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::labs(y = "Valeur de l'indicateur", color = "L\u00e9gende", caption = paste0("(N = ", n_farms, ")"))

    ## Economique

    ## Subset for dimension C
    indic_data <- IDEA_data$dataset %>%
      dplyr::inner_join(reference_table, by = c("indic" = "indic_code", "dimension_code", "component_code")) %>%
      dplyr::filter(dimension_code == "C") %>%
      dplyr::rowwise() %>%
      dplyr::mutate(full_name = wrapit(full_name, width = 75)) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(indic_number) %>%
      dplyr::mutate(full_name = factor(full_name, levels = rev(unique(full_name)))) %>%
      dplyr::mutate(component = factor(component, levels = unique(component)))

    ## Estimating means to add on the boxplot
    moys <- indic_data %>%
      dplyr::group_by(component, full_name, indic) %>%
      dplyr::summarise(Moyenne = mean(scaled_value))

    ## Plotting indicators for dimension C
    indic_ec_boxplot <- ggplot2::ggplot(indic_data, ggplot2::aes(x = full_name, y = scaled_value)) +
      ggplot2::stat_boxplot(geom = "errorbar", width = 0.3) +
      ggplot2::geom_boxplot(color = "black", fill = "#FE962B", width = 0.8) +
      ggplot2::geom_point(ggplot2::aes(y = 0), shape = 91, size = 5, color = "red") +
      ggplot2::geom_point(ggplot2::aes(y = max_indic), shape = 93, size = 5, color = "red") +
      ggplot2::facet_wrap(~component, ncol = 1, scales = "free") +
      ggplot2::coord_flip() +
      theme_idea() +
      ggplot2::scale_y_continuous(breaks = seq(0, 25, 1)) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::labs(y = "Valeur de l'indicateur", color = "L\u00e9gende", caption = paste0("(N = ", n_farms, ")"))


    ## Saving plots to plotlist
    plotlist$heatmap <- heatmap
    plotlist$dimensions_histogram <- dimensions_histogram
    plotlist$dimensions_boxplot <- dimensions_boxplot
    plotlist$components_boxplot <- components_boxplot
    plotlist$indic_ae_boxplot <- indic_ae_boxplot
    plotlist$indic_st_boxplot <- indic_st_boxplot
    plotlist$indic_ec_boxplot <- indic_ec_boxplot

    # Saving original data in the list for future usage in write.
    plotlist$data$metadata <- IDEA_data$metadata
    plotlist$data$dataset <- IDEA_data$dataset
    plotlist$data$nodes <- IDEA_data$nodes

    ## Assigning the appropriate class
    class(plotlist) <- c(class(plotlist), "IDEA_group_plots")
  }

  return(plotlist)
}
